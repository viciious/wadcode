#!/usr/bin/python3

#	Copyright (C) 2023 Victor Luchits
#
#	This file is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; this program is ONLY licensed under
#	version 3 of the License, later versions are explicitly excluded.
#
#	This file is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <https://www.gnu.org/licenses/>.

import json
import sys
import mmap
import struct
import os
from NamedStruct import NamedStruct
from io import BytesIO
from PIL import Image

MIPLEVELS = 1

writeheader = False
dirname = sys.argv[1]
if len(sys.argv) > 2:
    MIPLEVELS = int(sys.argv[2])
if len(sys.argv) > 3:
    writeheader = int(sys.argv[3]) != 0

with open(os.path.join(dirname, "content.json")) as f:
	content = json.load(f)

def findcontent(content, name, rev=False):
    in_sounds = False
    if rev:
        content = reversed(content)
    for e in content:
        if "name" not in e:
            continue
        if e["name"] == "DS_START":
            in_sounds = not rev
            continue
        if e["name"] == "DS_END":
            in_sounds = rev
            continue
        if in_sounds:
            continue
        if e["name"] == name:
            return e
    return None

filesdir = os.path.join(dirname, "files")
palname = os.path.join(filesdir, findcontent(content, "PLAYPALS")["filename"])
cmapname = os.path.join(filesdir, findcontent(content, "COLORMAP", True)["filename"])
colormap = bytearray(256)

def sqcolordist(rgb1, rgb2):
    ravg = (rgb1[0] + rgb2[0]) / 2
    r = rgb1[0] - rgb2[0]
    g = rgb1[1] - rgb2[1]
    b = rgb1[2] - rgb2[2]
    return (((512 + ravg) * r *r )/256) + 4 * g * g + (((767 - ravg)*b*b)/256)

def colormatch(r, g, b, d8to24, d24to8):
    c = r + (g<<8) + (b<<16)
    if c in d24to8:
        return d24to8[c]

    best = 0
    bestd = 0x1000000

    for j in range(256):
        d = sqcolordist((r, g, b), d8to24[j])
        if d < bestd:
            best = j
            bestd = d

    d15to8[c] = best
    return best

def swaprowcol(indata, width, height):
    outdata = bytearray()
    for i in range(height):
        for j in range(width):
            outdata.append(indata[j*height+i])
    return outdata

def noswaprowcol(indata, width, height):
    outdata = bytearray()
    outdata[:] = indata[:]
    return outdata

def genmip(indata, width, height, d8to24, d15to8):
    outwidth = width >> 1
    if outwidth < 1:
        outwidth = 1

    outheight = height >> 1
    if outheight < 1:
        outheight = 1

    inp = 0
    outdata = bytearray()

    for i in range(outheight):
        if i * 2 + 1 < height:
            nextofs = inp + width
        else:
            nextofs = inp

        n = 0
        for j in range(outwidth):
            if j * 2  + 1 < width:
                p1 = indata[inp+n]
                p2 = indata[inp+n+1]
                p3 = indata[nextofs+n]
                p4 = indata[nextofs+n+1]
            else:
                p1 = indata[inp+n]
                p2 = indata[inp+n]
                p3 = indata[nextofs+n]
                p4 = indata[nextofs+n]

            p1 = d8to24[p1]
            p2 = d8to24[p2]
            p3 = d8to24[p3]
            p4 = d8to24[p4]

            r = p1[0] + p2[0] + p3[0] + p4[0]
            g = p1[1] + p2[1] + p3[1] + p4[1]
            b = p1[2] + p2[2] + p3[2] + p4[2]

            r = (r >> 2) & 0xff
            g = (g >> 2) & 0xff
            b = (b >> 2) & 0xff

            c = colormatch(r, g, b, d8to24, d15to8)
            outdata.append(c)
            n = n + 2

        inp = inp + width*2

    return (outdata, outwidth, outheight)

def countcolors(name, data, width, height):
    colormap = {}
    for i in range(height):
        for j in range(width):
            c = data[j*height+i]
            colormap[c] = 1
    print ("Unique colors in", name, ":", len(colormap), "size:", width*height, "width:", width, "height:", height)
    return len(colormap)

def check_header(data, header, width, height):
    if len(data) < 16:
        return (data, None)

    header = header.unpack(data[0:16])
    if header.width == width and header.height == height and header.depth in (2,3):
        return (data[16:], header)
    return (data, None)

def convto4bpp(data, width, height, d8to24, d15to8):
    global colormap

    i, j = 0, 0

    extra = 0
    if (height & 1) != 0:
        extra = 1

    image = Image.frombytes('P', (height, width), data, 'raw', 'P')
    image.putpalette(pal)
    image = image.convert('RGB')
    image = image.convert('P', palette=Image.ADAPTIVE, colors=16)
    data = bytearray(image.tobytes())
    palette = image.getpalette()

    w = 0
    while w < width:
        h = 0
        while h < (height & ~extra):
            p1 = (data[j  ]) & 0xF
            p2 = (data[j+1]) & 0xF
            data[i] = (p1 << 4) | p2

            i += 1
            j += 2
            h += 2

        if extra != 0:
            p1 = (data[j]) & 0xF
            data[i] = p1 << 4
            i += 1
            j += 1

        w += 1

    data = data[:i]

    i = 0
    cmap = bytearray(33*16*2)
    for l in range(33):
        plen = int(len(palette)/3)

        for k in range(plen):
            m = colormatch(palette[k*3+0], palette[k*3+1], palette[k*3+2], d8to24, d15to8)
            if (m & 128) != 0:
                m = (m & 0x7f) - 128
            m = l*256 + 128 + m
            m = colormap[m]
            cmap[i  ] = m
            cmap[i+1] = m
            i = i + 2

        if plen < 16:
            for k in range(16-plen):
                cmap[i  ] = 0
                cmap[i+1] = 0
                i = i + 2

    return data + cmap

def noconv(data, width, height, d8to24, d15to8):
    return data

def genmips(fn, width, height, d8to24, d15to8, swap, bpp, headerstr=None, writeheader=True):
    levels = MIPLEVELS
    if fn.lower().startswith("sky"):
        levels = 1

    #if width < (1<<MIPLEVELS) or height < (1<<MIPLEVELS):
    #    return

    mips = [(bytearray(), 0, 0)] * levels
    mm = None

    with open(fn, "rb") as fin:
        print(fn)
        mm = mmap.mmap(fin.fileno(), 0, access=mmap.ACCESS_READ)

        data = mm
        if headerstr != None:
            data, header = check_header(data, headerstr, width, height)
            if header and header.depth == 2:
                print("bit depth is 2, skipping", fn)
                return
        data = swap(data, width, height)
        mips[0] = (data[:width*height], width, height)

        mipdata = data
        mipwidth = width
        mipheight = height

        for i in range(levels-1):
            mipdata, mipwidth, mipheight = genmip(mipdata, mipwidth, mipheight, d8to24, d15to8)
            mips[i+1] = (mipdata, mipwidth, mipheight)
    if mm:
        mm.close()

    with open(fn, "wb") as fout:
        if headerstr and writeheader:
            flags = 1
            if bpp == 2:
                flags = flags | 8
            header = headerstr.pack({"width": width, "height": height, "depth": bpp, "index": 0, "flags": flags, "pad2": 0, "pad3": 0, "pad4": 0})
            fout.write(header)
        conv = noconv
        if bpp == 2:
            conv = convto4bpp
        #countcolors(fn, mips[0][0], mips[0][2], mips[0][1])

        for i in range(levels):
            data = swap(mips[i][0], mips[i][2], mips[i][1])
            data = conv(data, mips[i][1], mips[i][2], d8to24, d15to8)
            fout.write(data)

# lump to json
tex1name = os.path.join(dirname, "texture1.json")

with open(tex1name, "rb") as fin:
    JagObjHeader = NamedStruct((
        ("h", "width"),
        ("h", "height"),
        ("h", "depth"),
        ("h", "index"),
        ("h", "flags"),
        ("h", "pad2"),
        ("h", "pad3"),
        ("h", "pad4"),
        ), ">")

    print("loading %s" % tex1name)
    arr = json.loads(fin.read())

    print("loading %s" % palname)
    with open(palname, "rb") as fin:
        pal = mmap.mmap(fin.fileno(), 0, access=mmap.ACCESS_READ)

        with open(cmapname, "rb") as fin:
            colormap = mmap.mmap(fin.fileno(), 0, access=mmap.ACCESS_READ)

            d8to24 = [(0,0,0)] * 256

            print("loading palette")
            for i in range(256):
                r = pal[i*3+0]
                g = pal[i*3+1]
                b = pal[i*3+2]
                d8to24[i] = (r,g,b)

            d15to8 = {}

            for i, entry in enumerate(arr):
                if "masked" in entry and entry["masked"]:
                    continue
                fn = entry["name"]
                fe = findcontent(content, fn.upper())
                if fe is None:
                    continue
                if "filename" not in fe:
                    continue
                fn = os.path.join(filesdir, fe["filename"])
              
                bpp = 3
                wh = writeheader
                if "depth" in entry and entry["depth"] == 2:
                    bpp = 2
                    wh = True

                genmips(fn, entry["width"], entry["height"], d8to24, d15to8, swaprowcol, bpp, JagObjHeader, wh)

            flats = False
            for e in content:
                if e["name"] == "F_END":
                    break
                if e["name"] == "F_START":
                    flats = True
                    continue
                if flats:
                    fn = e["filename"]
                    fn = os.path.join(filesdir, fn)
                    genmips(fn, 64, 64, d8to24, d15to8, noswaprowcol, 3)

            colormap.close()
        pal.close()
